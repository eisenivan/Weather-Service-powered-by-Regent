var e=e=>"function"==typeof e||"boolean"==typeof e,r=(r,t)=>{if(e(r))return"function"==typeof r?r(t):r;throw new Error(`Regent: "${r}" is not a valid rule`)};function t(e,r,t){const n={[t]:[]};return r.forEach(e=>{n[t].push("boolean"==typeof e?e:JSON.parse(e.toJson()))}),e.toJson=()=>JSON.stringify(n),e}var n=(...n)=>{if(!n.every(r=>e(r)))throw new Error("Regent: and requires all arguments to be a function");return t(function(e){return n.every(t=>r(t,e))},n,"and")};const o=(e,r)=>(e||(e={}),(e=e[(r=Array.isArray(r)?r:`${r}`.replace(/\[['"]?([\w\d-]+)['"]?\]/g,".$1").split(".").filter(e=>e))[0]])&&r.length>1?o(e,r.slice(1)):e),s=/^@@/,a=/^@/;function u(e){return"@"===e[0]?e.slice(1):e}var i=(e,...r)=>r.map(r=>{return!(e=>s.test(e))(t=r)&&a.test(t)?o(e,u(r)):u(r);var t}),f=(e,r)=>{if("function"!=typeof e)throw new Error("make must be passed a function as argument 1");return r&&"string"==typeof r||(r="unknown"),(...t)=>{const n={[r]:[]};t.forEach(e=>{n[r].push(e)});const o=r=>e(...i(r,...t),r);return o.toJson=()=>JSON.stringify(n),o}},p=f(e=>null==e||"undefined"===e||""===e,"empty"),c=f((e,r)=>e===r,"equals"),l=(e,r)=>{if("function"!=typeof e)throw new Error("makeWithContext must be passed a function as argument 1");return(t,n,o="__")=>{const s=r=>e(...i(r,t,n),o,r);return s.toJson=()=>{let e;return e="boolean"==typeof n?{[r]:[t,n]}:{[r]:[t,JSON.parse(n.toJson())]},JSON.stringify(e)},s}},y=l((t,n,o,s)=>{if(!e(n))throw new Error("Regent: the right property of an every rule must be a regent rule");return!!Array.isArray(t)&&t.every(e=>r(n,{...s,[o]:e}))},"every"),g=f((e,r)=>e>=r,"greaterThanOrEquals"),h=f((e,r)=>e>r,"greaterThan"),x=f((e,r)=>e<=r,"lessThanOrEquals"),m=f((e,r)=>e<r,"lessThan"),w=(...n)=>{if(!n.every(r=>e(r)))throw new Error("Regent: or requires all arguments to be a function");return t(function(e){return n.some(t=>r(t,e))},n,"or")},E=(...r)=>{if(!r.every(r=>e(r)))throw new Error("Regent: none requires all arguments to be a function");return t(function(e){return!w(...r)(e)},r,"none")},v=n=>{if(!e(n))throw new Error("Regent: not requires the first argument to be a function");return t(function(e){return!r(n,e)},[n],"not")},O=f((e,r)=>r.test(e),"regex"),b=l((t,n,o="__",s)=>{if(!e(n))throw new Error("Regent: the right property of an every rule must be a regent rule");return!!Array.isArray(t)&&t.some(e=>r(n,{...s,[o]:e}))},"some"),d=f((e,r)=>typeof e===r,"typeOf"),q=(...n)=>{if(!n.every(r=>e(r)))throw new Error("Regent: xor requires all arguments to be a function");if(2!==n.length)throw Error("Regent: xor must take exactly 2 rules");return t(function(e){return(r(n[0],e)||r(n[1],e))&&!(r(n[0],e)&&r(n[1],e))},n,"xor")};const T=p,J=c,R=y,k=g,A=h,N=x,S=m,$=f,_=E,j=v,C=w,W=O,z=b,B=d,D=q;exports.and=n,exports.empty=T,exports.equals=J,exports.every=R,exports.filter=(t,n)=>t.filter(t=>!!e(t.rule)&&r(t.rule,n)),exports.find=(t,n)=>t.find(t=>!!e(t.rule)&&r(t.rule,n)),exports.greaterThan=A,exports.greaterThanOrEquals=k,exports.lessThan=S,exports.lessThanOrEquals=N,exports.make=$,exports.none=_,exports.not=j,exports.or=C,exports.parse=(e={})=>{const r={};try{const t=JSON.parse(e);Object.keys(t).forEach(e=>{r[e]=function e(r){if("boolean"==typeof r)return r;const t="string"==typeof r?r:Object.keys(r)[0];switch(t){case"empty":return p(...r[t]);case"equals":return c(...r[t]);case"greaterThanOrEquals":return g(...r[t]);case"greaterThan":return h(...r[t]);case"lessThanOrEquals":return x(...r[t]);case"lessThan":return m(...r[t]);case"regex":return O(r[t][0],new RegExp(r[t][1]));case"typeOf":return d(...r[t]);case"and":return n(...r[t].map(r=>e(r)));case"every":return y(r[t][0],e(r[t][1]));case"none":return E(...r[t].map(r=>e(r)));case"not":return v(...r[t].map(r=>e(r)));case"or":return w(...r[t].map(r=>e(r)));case"some":return b(r[t][0],e(r[t][1]));case"xor":return q(...r[t].map(r=>e(r)));default:return`${t} is not a valid predicate`}}(t[e])})}catch(e){console.error(`regent.parse ${e}`)}return r},exports.regex=W,exports.some=z,exports.typeOf=B,exports.xor=D;
//# sourceMappingURL=regent.js.map
