var e=e=>"function"==typeof e||"boolean"==typeof e,r=(r,t)=>{if(e(r))return"function"==typeof r?r(t):r;throw new Error(`Regent: "${r}" is not a valid rule`)};function t(e,r,t){const n={[t]:[]};return r.forEach(e=>{n[t].push("boolean"==typeof e?e:JSON.parse(e.toJson()))}),e.toJson=()=>JSON.stringify(n),e}var n=(...n)=>{if(!n.every(r=>e(r)))throw new Error("Regent: and requires all arguments to be a function");return t(function(e){return n.every(t=>r(t,e))},n,"and")};const a=(e,r)=>(e||(e={}),(e=e[(r=Array.isArray(r)?r:`${r}`.replace(/\[['"]?([\w\d-]+)['"]?\]/g,".$1").split(".").filter(e=>e))[0]])&&r.length>1?a(e,r.slice(1)):e),o=/^@@/,s=/^@/;function u(e){return"@"===e[0]?e.slice(1):e}var i=(e,...r)=>r.map(r=>{return!(e=>o.test(e))(t=r)&&s.test(t)?a(e,u(r)):u(r);var t}),f=(e,r)=>{if("function"!=typeof e)throw new Error("make must be passed a function as argument 1");return r&&"string"==typeof r||(r="unknown"),(...t)=>{const n={[r]:[]};t.forEach(e=>{n[r].push(e)});const a=r=>e(...i(r,...t),r);return a.toJson=()=>JSON.stringify(n),a}},c=f(e=>null==e||"undefined"===e||""===e,"empty"),l=f((e,r)=>e===r,"equals"),y=(e,r)=>{if("function"!=typeof e)throw new Error("makeWithContext must be passed a function as argument 1");return(t,n,a="__")=>{const o=r=>e(...i(r,t,n),a,r);return o.toJson=()=>{let e;return e="boolean"==typeof n?{[r]:[t,n]}:{[r]:[t,JSON.parse(n.toJson())]},JSON.stringify(e)},o}},p=y((t,n,a,o)=>{if(!e(n))throw new Error("Regent: the right property of an every rule must be a regent rule");return!!Array.isArray(t)&&t.every(e=>r(n,{...o,[a]:e}))},"every"),g=f((e,r)=>e>=r,"greaterThanOrEquals"),h=f((e,r)=>e>r,"greaterThan"),m=f((e,r)=>e<=r,"lessThanOrEquals"),w=f((e,r)=>e<r,"lessThan"),E=(...n)=>{if(!n.every(r=>e(r)))throw new Error("Regent: or requires all arguments to be a function");return t(function(e){return n.some(t=>r(t,e))},n,"or")},v=(...r)=>{if(!r.every(r=>e(r)))throw new Error("Regent: none requires all arguments to be a function");return t(function(e){return!E(...r)(e)},r,"none")},O=n=>{if(!e(n))throw new Error("Regent: not requires the first argument to be a function");return t(function(e){return!r(n,e)},[n],"not")},b=f((e,r)=>r.test(e),"regex"),q=y((t,n,a="__",o)=>{if(!e(n))throw new Error("Regent: the right property of an every rule must be a regent rule");return!!Array.isArray(t)&&t.some(e=>r(n,{...o,[a]:e}))},"some"),d=f((e,r)=>typeof e===r,"typeOf"),T=(...n)=>{if(!n.every(r=>e(r)))throw new Error("Regent: xor requires all arguments to be a function");if(2!==n.length)throw Error("Regent: xor must take exactly 2 rules");return t(function(e){return(r(n[0],e)||r(n[1],e))&&!(r(n[0],e)&&r(n[1],e))},n,"xor")};const x=n,J=c,R=l,k=p,A=(t,n)=>t.filter(t=>!!e(t.rule)&&r(t.rule,n)),N=(t,n)=>t.find(t=>!!e(t.rule)&&r(t.rule,n)),S=g,$=h,_=(e={})=>{const r={};try{const t=JSON.parse(e);Object.keys(t).forEach(e=>{r[e]=function e(r){if("boolean"==typeof r)return r;const t="string"==typeof r?r:Object.keys(r)[0];switch(t){case"empty":return c(...r[t]);case"equals":return l(...r[t]);case"greaterThanOrEquals":return g(...r[t]);case"greaterThan":return h(...r[t]);case"lessThanOrEquals":return m(...r[t]);case"lessThan":return w(...r[t]);case"regex":return b(r[t][0],new RegExp(r[t][1]));case"typeOf":return d(...r[t]);case"and":return n(...r[t].map(r=>e(r)));case"every":return p(r[t][0],e(r[t][1]));case"none":return v(...r[t].map(r=>e(r)));case"not":return O(...r[t].map(r=>e(r)));case"or":return E(...r[t].map(r=>e(r)));case"some":return q(r[t][0],e(r[t][1]));case"xor":return T(...r[t].map(r=>e(r)));default:return`${t} is not a valid predicate`}}(t[e])})}catch(e){console.error(`regent.parse ${e}`)}return r},j=m,C=w,W=f,z=v,B=O,D=E,F=b,G=q,H=d,I=T;export{x as and,J as empty,R as equals,k as every,A as filter,N as find,$ as greaterThan,S as greaterThanOrEquals,C as lessThan,j as lessThanOrEquals,W as make,z as none,B as not,D as or,_ as parse,F as regex,G as some,H as typeOf,I as xor};
//# sourceMappingURL=regent.modern.module.js.map
