{"version":3,"file":"regent.umd.js","sources":["../src/private/is-rule.js","../src/private/evaluate-rule.js","../src/private/attach-to-json.js","../src/functions/and.js","../src/private/get.js","../src/private/is-escaped.js","../src/private/is-lookup.js","../src/private/strip-at.js","../src/private/make-args.js","../src/functions/make.js","../src/functions/empty.js","../src/functions/equals.js","../src/private/make-with-context.js","../src/functions/every.js","../src/functions/greater-than-equals.js","../src/functions/greater-than.js","../src/functions/less-than-equals.js","../src/functions/less-than.js","../src/functions/or.js","../src/functions/none.js","../src/functions/not.js","../src/functions/regex.js","../src/functions/some.js","../src/functions/type-of.js","../src/functions/xor.js","../src/regent.js","../src/functions/filter.js","../src/functions/find.js","../src/functions/parse.js"],"sourcesContent":["export default testRule => typeof testRule === 'function' || typeof testRule === 'boolean'\n","import isRule from './is-rule'\n\nexport default (rule, data) => {\n  if (isRule(rule)) {\n    return typeof rule === 'function' ? rule(data) : rule\n  }\n\n  // If this isn't a rule, throw\n  throw new Error(`Regent: \"${rule}\" is not a valid rule`)\n}\n","export default function attachToJson (fn, rules, name) {\n  const ruleJson = { [name]: [] }\n\n  rules.forEach((rule) => {\n    if (typeof rule === 'boolean') {\n      ruleJson[name].push(rule)\n    } else {\n      ruleJson[name].push(JSON.parse(rule.toJson()))\n    }\n  })\n\n  fn.toJson = () => JSON.stringify(ruleJson)\n\n  return fn\n}\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\nimport attachToJson from '../private/attach-to-json'\n\nexport default (...rules) => {\n  // throw if one or more of the rules are\n  // not rules\n  if (!rules.every(x => isRule(x))) {\n    throw new Error('Regent: and requires all arguments to be a function')\n  }\n\n  return attachToJson(function and (data) {\n    return rules.every(x => evaluateRule(x, data))\n  }, rules, 'and')\n}\n","const get = (object, keys) => {\n  if (!object) { object = {} }\n\n  keys = Array.isArray(keys) ? keys : `${keys}`\n    .replace(/\\[['\"]?([\\w\\d-]+)['\"]?\\]/g, '.$1')\n    .split('.')\n    .filter(x => x)\n\n  object = object[keys[0]]\n\n  if (object && keys.length > 1) {\n    return get(object, keys.slice(1))\n  }\n\n  return object\n}\n\nexport default get\n","const isEscapedRegex = /^@@/\nexport default arg => isEscapedRegex.test(arg)\n","import isEscaped from './is-escaped'\n\nconst isLookupRegex = /^@/\n\nexport default function isLookup (arg) {\n  // If it's an escaped string then it's not a lookup?\n  if (isEscaped(arg)) {\n    return false\n  }\n  // If it makes it to here and it matches the following regex then it is a lookup.\n  return isLookupRegex.test(arg)\n}\n","export default function stripAt (arg) {\n  return arg[0] === '@'\n    ? arg.slice(1)\n    : arg\n}\n","import get from './get'\nimport isLookup from './is-lookup'\nimport stripAt from './strip-at'\n\n// makeArgs will sort out if the leftArg and rightArg are lookups or\n// static and return the the data that your predicates needs.\nexport default (data, ...args) => args.map(x => isLookup(x) ? get(data, stripAt(x)) : stripAt(x))\n","import makeArgs from '../private/make-args'\n\nexport default (fn, name) => {\n  if (typeof fn !== 'function') {\n    throw new Error('make must be passed a function as argument 1')\n  }\n\n  if (!name || typeof name !== 'string') {\n    name = 'unknown'\n  }\n\n  return (...args) => {\n    const ruleJson = { [name]: [] }\n\n    args.forEach((arg) => {\n      ruleJson[name].push(arg)\n    })\n\n    const ruleFn = data => fn(...makeArgs(data, ...args), data)\n\n    ruleFn.toJson = () => JSON.stringify(ruleJson)\n\n    return ruleFn\n  }\n}\n","import make from './make'\n\nexport const empty = input => (\n  input === undefined ||\n  input === null ||\n  input === 'undefined' ||\n  input === ''\n)\n\nexport default make(empty, 'empty')\n","import make from './make'\n\nexport const equals = (left, right) => left === right\n\nexport default make(equals, 'equals')\n","import makeArgs from './make-args'\n\nexport default (fn, name) => {\n  if (typeof fn !== 'function') {\n    throw new Error('makeWithContext must be passed a function as argument 1')\n  }\n\n  return (left, right, context = '__') => {\n    const ruleFn = data =>\n      fn(...makeArgs(data, left, right), context, data)\n\n    ruleFn.toJson = () => {\n      let ruleJson\n\n      if (typeof right === 'boolean') {\n        ruleJson = { [name]: [left, right] }\n      } else {\n        ruleJson = { [name]: [left, JSON.parse(right.toJson())] }\n      }\n\n      return JSON.stringify(ruleJson)\n    }\n\n    return ruleFn\n  }\n}\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\nimport makeWithContext from '../private/make-with-context'\n\nexport const every = (left, right, context, data) => {\n  if (!isRule(right)) {\n    throw new Error('Regent: the right property of an every rule must be a regent rule')\n  }\n\n  if (!Array.isArray(left)) {\n    return false\n  }\n\n  return left.every(x => evaluateRule(right, { ...data, [context]: x }))\n}\n\nexport default makeWithContext(every, 'every')\n","import make from './make'\n\nexport const greaterThanOrEquals = (left, right) => left >= right\n\nexport default make(greaterThanOrEquals, 'greaterThanOrEquals')\n","import make from './make'\n\nexport const greaterThan = (left, right) => left > right\n\nexport default make(greaterThan, 'greaterThan')\n","import make from './make'\n\nexport const lessThanOrEquals = (left, right) => left <= right\nexport default make(lessThanOrEquals, 'lessThanOrEquals')\n","import make from './make'\n\nexport const lessThan = (left, right) => left < right\nexport default make(lessThan, 'lessThan')\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\nimport attachToJson from '../private/attach-to-json'\n\nexport default (...rules) => {\n  // throw if one or more of the rules are\n  // not rules\n  if (!rules.every(x => isRule(x))) {\n    throw new Error('Regent: or requires all arguments to be a function')\n  }\n\n  return attachToJson(function or (data) {\n    return rules.some(x => evaluateRule(x, data))\n  }, rules, 'or')\n}\n","import or from './or'\nimport isRule from '../private/is-rule'\nimport attachToJson from '../private/attach-to-json'\n\nexport default (...rules) => {\n  if (!rules.every(x => isRule(x))) {\n    throw new Error('Regent: none requires all arguments to be a function')\n  }\n\n  return attachToJson(function none (data) {\n    return !or(...rules)(data)\n  }, rules, 'none')\n}\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\nimport attachToJson from '../private/attach-to-json'\n\nexport default (rule) => {\n  if (!isRule(rule)) {\n    throw new Error('Regent: not requires the first argument to be a function')\n  }\n\n  return attachToJson(function not (data) {\n    return !evaluateRule(rule, data)\n  }, [rule], 'not')\n}\n","import make from './make'\n\nexport const regex = (left, right) => right.test(left)\nexport default make(regex, 'regex')\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\nimport makeWithContext from '../private/make-with-context'\n\nexport const some = (left, right, context = '__', data) => {\n  if (!isRule(right)) {\n    throw new Error('Regent: the right property of an every rule must be a regent rule')\n  }\n\n  if (!Array.isArray(left)) {\n    return false\n  }\n\n  return left.some(x => evaluateRule(right, { ...data, [context]: x }))\n}\n\nexport default makeWithContext(some, 'some')\n","import make from './make'\n\nexport const typeOf = (left, right) => typeof left === right; // eslint-disable-line\nexport default make(typeOf, 'typeOf')\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\nimport attachToJson from '../private/attach-to-json'\n\nexport default (...rules) => {\n  // throw if one or more of the rules are\n  // not rules\n  if (!rules.every(x => isRule(x))) {\n    throw new Error('Regent: xor requires all arguments to be a function')\n  }\n\n  if (rules.length !== 2) {\n    throw Error('Regent: xor must take exactly 2 rules')\n  }\n  return attachToJson(function xor (data) {\n    return (evaluateRule(rules[0], data) || evaluateRule(rules[1], data)) && !(evaluateRule(rules[0], data) && evaluateRule(rules[1], data))\n  }, rules, 'xor')\n}\n","import andFn from './functions/and'\nimport emptyFn from './functions/empty'\nimport equalsFn from './functions/equals'\nimport everyFn from './functions/every'\nimport filterFn from './functions/filter'\nimport findFn from './functions/find'\nimport greaterThanOrEqualsFn from './functions/greater-than-equals'\nimport greaterThanFn from './functions/greater-than'\nimport parseFn from './functions/parse'\nimport lessThanOrEqualsFn from './functions/less-than-equals'\nimport lessThanFn from './functions/less-than'\nimport makeFn from './functions/make'\nimport noneFn from './functions/none'\nimport notFn from './functions/not'\nimport orFn from './functions/or'\nimport regexFn from './functions/regex'\nimport someFn from './functions/some'\nimport typeOfFn from './functions/type-of'\nimport xorFn from './functions/xor'\n\nexport const and = andFn\nexport const empty = emptyFn\nexport const equals = equalsFn\nexport const every = everyFn\nexport const filter = filterFn\nexport const find = findFn\nexport const greaterThanOrEquals = greaterThanOrEqualsFn\nexport const greaterThan = greaterThanFn\nexport const parse = parseFn\nexport const lessThanOrEquals = lessThanOrEqualsFn\nexport const lessThan = lessThanFn\nexport const make = makeFn\nexport const none = noneFn\nexport const not = notFn\nexport const or = orFn\nexport const regex = regexFn\nexport const some = someFn\nexport const typeOf = typeOfFn\nexport const xor = xorFn\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\n\nexport default (logic, data) => logic.filter((x) => {\n  if (isRule(x.rule)) {\n    return evaluateRule(x.rule, data)\n  }\n\n  return false\n})\n","import isRule from '../private/is-rule'\nimport evaluateRule from '../private/evaluate-rule'\n\nexport default (logic, data) => logic.find((x) => {\n  if (isRule(x.rule)) {\n    return evaluateRule(x.rule, data)\n  }\n\n  return false\n})\n","import and from './and'\nimport empty from './empty'\nimport equals from './equals'\nimport every from './every'\nimport greaterThanOrEquals from './greater-than-equals'\nimport greaterThan from './greater-than'\nimport lessThanOrEquals from './less-than-equals'\nimport lessThan from './less-than'\nimport none from './none'\nimport not from './not'\nimport or from './or'\nimport regex from './regex'\nimport some from './some'\nimport typeOf from './type-of'\nimport xor from './xor'\n\nexport function buildRule (jsonRule) {\n  // if typeof jsonRule === boolean\n  // return it\n  if (typeof jsonRule === 'boolean') {\n    return jsonRule\n  }\n\n  // If jsonRule is a string, return it for a more helpful error message\n  // else return the first key\n  const predicate = typeof jsonRule === 'string'\n    ? jsonRule\n    : Object.keys(jsonRule)[0]\n\n  switch (predicate) {\n    case 'empty':\n      return empty(...jsonRule[predicate])\n\n    case 'equals':\n      return equals(...jsonRule[predicate])\n\n    case 'greaterThanOrEquals':\n      return greaterThanOrEquals(...jsonRule[predicate])\n\n    case 'greaterThan':\n      return greaterThan(...jsonRule[predicate])\n\n    case 'lessThanOrEquals':\n      return lessThanOrEquals(...jsonRule[predicate])\n\n    case 'lessThan':\n      return lessThan(...jsonRule[predicate])\n\n    case 'regex':\n      // first argument is a key or literal, second is a string\n      // representing a regex that needs to be parsed\n      return regex(jsonRule[predicate][0], new RegExp(jsonRule[predicate][1]))\n\n    case 'typeOf':\n      return typeOf(...jsonRule[predicate])\n\n    // composed rules\n    case 'and':\n      return and(...jsonRule[predicate].map(x => buildRule(x)))\n\n    case 'every':\n      // first argument is the key, the second is a rule to be built\n      return every(jsonRule[predicate][0], buildRule(jsonRule[predicate][1]))\n\n    case 'none':\n      return none(...jsonRule[predicate].map(x => buildRule(x)))\n\n    case 'not':\n      return not(...jsonRule[predicate].map(x => buildRule(x)))\n\n    case 'or':\n      return or(...jsonRule[predicate].map(x => buildRule(x)))\n\n    case 'some':\n      // first argument is the key, the second is a rule to be built\n      return some(jsonRule[predicate][0], buildRule(jsonRule[predicate][1]))\n\n    case 'xor':\n      return xor(...jsonRule[predicate].map(x => buildRule(x)))\n\n    default:\n      return `${predicate} is not a valid predicate`\n  }\n}\n\nexport default (json = {}) => {\n  const result = {}\n\n  try {\n    const rules = JSON.parse(json)\n\n    Object.keys(rules).forEach((key) => {\n      result[key] = buildRule(rules[key])\n    })\n  } catch (e) {\n    console.error(`regent.parse ${e}`)\n  }\n\n  return result\n}\n"],"names":["testRule","rule","data","isRule","Error","attachToJson","fn","rules","name","ruleJson","[object Object]","forEach","push","JSON","parse","toJson","stringify","every","x","evaluateRule","get","object","keys","Array","isArray","replace","split","filter","length","slice","isEscapedRegex","isLookupRegex","stripAt","arg","args","map","isLookup","test","isEscaped","ruleFn","makeArgs","make","input","left","right","context","makeWithContext","some","or","empty","emptyFn","equals","equalsFn","everyFn","greaterThanOrEquals","greaterThanOrEqualsFn","greaterThan","greaterThanFn","lessThanOrEquals","lessThanOrEqualsFn","lessThan","lessThanFn","makeFn","none","noneFn","not","notFn","orFn","regex","regexFn","someFn","typeOf","typeOfFn","xor","xorFn","andFn","logic","find","json","result","Object","key","buildRule","jsonRule","predicate","RegExp","and","e","console","error"],"mappings":"4LAAeA,GAAgC,mBAAbA,GAA+C,kBAAbA,KCEpDC,EAAMC,KACpB,GAAIC,EAAOF,GACT,MAAuB,mBAATA,EAAsBA,EAAKC,GAAQD,EAInD,UAAUG,MAAO,YAAWH,oCCRNI,EAAcC,EAAIC,EAAOC,GAC/C,MAAMC,EAAW,CAAEC,CAACF,GAAO,IAY3B,OAVAD,EAAMI,QAASV,IAEXQ,EAASD,GAAMI,KADG,kBAATX,EACWA,EAEAY,KAAKC,MAAMb,EAAKc,aAIxCT,EAAGS,OAAS,IAAMF,KAAKG,UAAUP,GAE1BH,YCTUC,KAGjB,IAAKA,EAAMU,MAAMC,GAAKf,EAAOe,IAC3B,UAAUd,MAAM,uDAGlB,OAAOC,EAAa,SAAcH,GAChC,OAAOK,EAAMU,MAAMC,GAAKC,EAAaD,EAAGhB,KACvCK,EAAO,QCbZ,MAAMa,EAAM,CAACC,EAAQC,KACdD,IAAUA,EAAS,KAOxBA,EAASA,GALTC,EAAOC,MAAMC,QAAQF,GAAQA,EAAQ,GAAEA,IACpCG,QAAQ,4BAA6B,OACrCC,MAAM,KACNC,OAAOT,GAAKA,IAEM,MAEPI,EAAKM,OAAS,EACnBR,EAAIC,EAAQC,EAAKO,MAAM,IAGzBR,GCdHS,EAAiB,MCEjBC,EAAgB,cCFEC,EAASC,GAC/B,MAAkB,MAAXA,EAAI,GACPA,EAAIJ,MAAM,GACVI,SCGU/B,KAASgC,IAASA,EAAKC,IAAIjB,IAAKkB,QHLjCH,GAAOH,EAAeO,KAAKJ,GCKpCK,CAF4BL,EEEuBf,IFIhDa,EAAcM,KAAKJ,GEJkCb,EAAIlB,EAAM8B,EAAQd,IAAMc,EAAQd,OFF5De,OGFlB3B,EAAIE,KAClB,GAAkB,mBAAPF,EACT,UAAUF,MAAM,gDAOlB,OAJKI,GAAwB,iBAATA,IAClBA,EAAO,WAGF,IAAI0B,KACT,MAAMzB,EAAW,CAAEC,CAACF,GAAO,IAE3B0B,EAAKvB,QAASsB,IACZxB,EAASD,GAAMI,KAAKqB,KAGtB,MAAMM,EAASrC,GAAQI,KAAMkC,EAAStC,KAASgC,GAAOhC,GAItD,OAFAqC,EAAOxB,OAAS,IAAMF,KAAKG,UAAUP,GAE9B8B,MCbIE,EAPMC,GACnBA,MAAAA,GAEU,cAAVA,GACU,KAAVA,EAGyB,WCLZD,EAFO,CAACE,EAAMC,IAAUD,IAASC,EAEpB,aCFZtC,EAAIE,KAClB,GAAkB,mBAAPF,EACT,UAAUF,MAAM,2DAGlB,MAAO,CAACuC,EAAMC,EAAOC,EAAU,QAC7B,MAAMN,EAASrC,GACbI,KAAMkC,EAAStC,EAAMyC,EAAMC,GAAQC,EAAS3C,GAc9C,OAZAqC,EAAOxB,OAAS,KACd,IAAIN,EAQJ,OALEA,EADmB,kBAAVmC,EACE,CAAElC,CAACF,GAAO,CAACmC,EAAMC,IAEjB,CAAElC,CAACF,GAAO,CAACmC,EAAM9B,KAAKC,MAAM8B,EAAM7B,YAGxCF,KAAKG,UAAUP,IAGjB8B,MCPIO,EAZM,CAACH,EAAMC,EAAOC,EAAS3C,KAC1C,IAAKC,EAAOyC,GACV,UAAUxC,MAAM,qEAGlB,QAAKmB,MAAMC,QAAQmB,IAIZA,EAAK1B,MAAMC,GAAKC,EAAayB,EAAO,IAAK1C,EAAMQ,CAACmC,GAAU3B,MAG7B,WCZvBuB,EAFoB,CAACE,EAAMC,IAAUD,GAAQC,EAEnB,yBCA1BH,EAFY,CAACE,EAAMC,IAAUD,EAAOC,EAElB,iBCDlBH,EADiB,CAACE,EAAMC,IAAUD,GAAQC,EACnB,sBCAvBH,EADS,CAACE,EAAMC,IAAUD,EAAOC,EAClB,kBCCXrC,KAGjB,IAAKA,EAAMU,MAAMC,GAAKf,EAAOe,IAC3B,UAAUd,MAAM,sDAGlB,OAAOC,EAAa,SAAaH,GAC/B,OAAOK,EAAMwC,KAAK7B,GAAKC,EAAaD,EAAGhB,KACtCK,EAAO,aCTOA,KACjB,IAAKA,EAAMU,MAAMC,GAAKf,EAAOe,IAC3B,UAAUd,MAAM,wDAGlB,OAAOC,EAAa,SAAeH,GACjC,OAAQ8C,KAAMzC,EAANyC,CAAa9C,IACpBK,EAAO,WCPIN,IACd,IAAKE,EAAOF,GACV,UAAUG,MAAM,4DAGlB,OAAOC,EAAa,SAAcH,GAChC,OAAQiB,EAAalB,EAAMC,IAC1B,CAACD,GAAO,UCREwC,EADM,CAACE,EAAMC,IAAUA,EAAMP,KAAKM,GACtB,WCaZG,EAZK,CAACH,EAAMC,EAAOC,EAAU,KAAM3C,KAChD,IAAKC,EAAOyC,GACV,UAAUxC,MAAM,qEAGlB,QAAKmB,MAAMC,QAAQmB,IAIZA,EAAKI,KAAK7B,GAAKC,EAAayB,EAAO,IAAK1C,EAAMQ,CAACmC,GAAU3B,MAG7B,UCbtBuB,EADO,CAACE,EAAMC,WAAiBD,IAASC,EAC3B,gBCCTrC,KAGjB,IAAKA,EAAMU,MAAMC,GAAKf,EAAOe,IAC3B,UAAUd,MAAM,uDAGlB,GAAqB,IAAjBG,EAAMqB,OACR,MAAMxB,MAAM,yCAEd,OAAOC,EAAa,SAAcH,GAChC,OAAQiB,EAAaZ,EAAM,GAAIL,IAASiB,EAAaZ,EAAM,GAAIL,OAAYiB,EAAaZ,EAAM,GAAIL,IAASiB,EAAaZ,EAAM,GAAIL,KACjIK,EAAO,cCKC0C,EAAQC,EACRC,EAASC,EACTnC,EAAQoC,EAGRC,EAAsBC,EACtBC,EAAcC,EAEdC,EAAmBC,EACnBC,EAAWC,EACXpB,EAAOqB,EACPC,EAAOC,EACPC,EAAMC,EACNlB,EAAKmB,EACLC,EAAQC,EACRtB,EAAOuB,EACPC,EAASC,EACTC,EAAMC,QAlBAC,2CCjBHC,EAAO1E,IAAS0E,EAAMjD,OAAQT,KACxCf,EAAOe,EAAEjB,OACJkB,EAAaD,EAAEjB,KAAMC,YCFhB0E,EAAO1E,IAAS0E,EAAMC,KAAM3D,KACtCf,EAAOe,EAAEjB,OACJkB,EAAaD,EAAEjB,KAAMC,wHCgFhB4E,EAAO,MACrB,MAAMC,EAAS,GAEf,IACE,MAAMxE,EAAQM,KAAKC,MAAMgE,GAEzBE,OAAO1D,KAAKf,GAAOI,QAASsE,IAC1BF,EAAOE,YA5EGC,EAAWC,GAGzB,GAAwB,kBAAbA,EACT,OAAOA,EAKT,MAAMC,EAAgC,iBAAbD,EACrBA,EACAH,OAAO1D,KAAK6D,GAAU,GAE1B,OAAQC,GACN,IAAK,QACH,OAAOnC,KAASkC,EAASC,IAE3B,IAAK,SACH,OAAOjC,KAAUgC,EAASC,IAE5B,IAAK,sBACH,OAAO9B,KAAuB6B,EAASC,IAEzC,IAAK,cACH,OAAO5B,KAAe2B,EAASC,IAEjC,IAAK,mBACH,OAAO1B,KAAoByB,EAASC,IAEtC,IAAK,WACH,OAAOxB,KAAYuB,EAASC,IAE9B,IAAK,QAGH,OAAOhB,EAAMe,EAASC,GAAW,GAAI,IAAIC,OAAOF,EAASC,GAAW,KAEtE,IAAK,SACH,OAAOb,KAAUY,EAASC,IAG5B,IAAK,MACH,OAAOE,KAAOH,EAASC,GAAWjD,IAAIjB,GAAKgE,EAAUhE,KAEvD,IAAK,QAEH,OAAOD,EAAMkE,EAASC,GAAW,GAAIF,EAAUC,EAASC,GAAW,KAErE,IAAK,OACH,OAAOrB,KAAQoB,EAASC,GAAWjD,IAAIjB,GAAKgE,EAAUhE,KAExD,IAAK,MACH,OAAO+C,KAAOkB,EAASC,GAAWjD,IAAIjB,GAAKgE,EAAUhE,KAEvD,IAAK,KACH,OAAO8B,KAAMmC,EAASC,GAAWjD,IAAIjB,GAAKgE,EAAUhE,KAEtD,IAAK,OAEH,OAAO6B,EAAKoC,EAASC,GAAW,GAAIF,EAAUC,EAASC,GAAW,KAEpE,IAAK,MACH,OAAOX,KAAOU,EAASC,GAAWjD,IAAIjB,GAAKgE,EAAUhE,KAEvD,QACE,MAAQ,GAAEkE,8BAWIF,CAAU3E,EAAM0E,MAEhC,MAAOM,GACPC,QAAQC,MAAO,gBAAeF,KAGhC,OAAOR"}